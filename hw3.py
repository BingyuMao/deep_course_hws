# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.

"""

# Commented out IPython magic to ensure Python compatibility.
#Code reference: https://colab.research.google.com/drive/1LCFUUxZ3gBRCmdySbeSDXNn0ygtDkyxA#scrollTo=OZItfQbKkaOO
#Packages
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

import random
random.seed(1111) #random seed

# This package is to avoid system error
import os
os.environ['KMP_DUPLICATE_LIB_OK']='True'
# This package is to make sure my macbook can print the figure out 
# (My macbook system is Big Sur which cause "segmentation fault" when trying to plot)
import matplotlib as mpl
mpl.use('tkagg')

#Create data
x_train = []
y_correct = []
for i in range(500):
    x0 = random.randint(-6, 6)
    x1 = random.randint(-6, 6)
    label = 0 if x0 * x1 > 0 else 1
    x_train.append([x0, x1])
    y_correct.append(label)
x_train = np.asarray(x_train)
y_correct = np.asarray(y_correct)

#Define the model
class XorClassifier(nn.Module):

    def __init__(self, input_dim, output_dim):

        super(XorClassifier, self).__init__() 

        self.inp = nn.Linear(input_dim, 32)
        self.hid = nn.Linear(32, 8)
        self.out = nn.Linear(8, output_dim)
        self.tanh = nn.Tanh()

    def forward(self, x):

        h_1 = F.relu(self.inp(x))
        h_2 = F.relu(self.hid(h_1))
        out = self.out(h_2)
        out = self.tanh(out)

        return out

#Create the model
model = XorClassifier(2,2)

criterion = nn.CrossEntropyLoss()
learning_rate = 0.01
optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)

epochs = 2000

#Model training
for epoch in range(epochs):
    inputs = torch.from_numpy(x_train).type(torch.FloatTensor)
    labels = torch.from_numpy(y_correct)

    optimizer.zero_grad()
    outputs = model.forward(inputs)
    loss = criterion(outputs, labels)
    loss.backward()
    optimizer.step()
    if epoch % 200 == 0:
        print('epoch {}, loss {}'.format(epoch, loss.item()))

#Plot
outputs = model.forward(torch.from_numpy(x_train).type(torch.FloatTensor))
_, predicted = torch.max(outputs, 1)

fig, ax = plt.subplots()
for i in range(y_correct.shape[0]):
    if predicted[i] == 0:
        marker = 'ro'
    else:
        marker = 'bo'
    ax.plot(x_train[i][0], x_train[i][1], marker)
ax.axhline(y=0, color='k')
ax.axvline(x=0, color='k')
plt.show()
